<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>横スクロールアクション - game.html</title>
  <style>
    :root { --bg:#0f1126; --fg:#eaf2ff; --hud:rgba(0,0,0,.35); --accent2:#ffd169; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial}
    #wrap{display:grid;place-items:center;height:100%}
    canvas{width:min(100vw,1100px);height:min(100vh,650px);image-rendering:pixelated;background:linear-gradient(#1a1f44,#0f1126 60%);border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.5),inset 0 0 0 1px rgba(255,255,255,.05)}
    .hud{position:absolute;top:12px;left:12px;padding:6px 10px;background:var(--hud);border-radius:10px;backdrop-filter:blur(6px);font-weight:700}
    .hud .lives{display:inline-flex;gap:6px;align-items:center}
    .badge{display:inline-block;width:16px;height:16px;background:var(--accent2);border-radius:4px;box-shadow:inset 0 -2px 0 rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.25)}
    .credit{position:absolute;bottom:10px;right:12px;font-size:11px;opacity:.6}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1100" height="650" aria-label="横スクロールアクションゲーム"></canvas>
    <div class="hud" id="hud"><span class="lives"><span class="badge"></span> LIVES <span id="livesText">x3</span></span></div>
    <div class="credit">© You</div>
  </div>

  <script>
  // ================================
  // スプライト差し替え設定
  // ================================
  const PLAYER_SPRITE_URL = "";       // 通常プレイヤー
  const PLAYER_SPRITE_HIT_URL = "";   // ミス時プレイヤー
  const ENEMY_SPRITE_URL = "";        // 通常敵
  const ENEMY_SPRITE_DEAD_URL = "";   // 倒された敵

  // ================================
  // 基本ユーティリティ
  // ================================
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now();

  // キー
  const Keys = { left:false, right:false, up:false, start:false };
  addEventListener('keydown',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') Keys.left=true;
    if(e.code==='ArrowRight'||e.code==='KeyD') Keys.right=true;
    if(e.code==='ArrowUp'||e.code==='Space'||e.code==='KeyW') Keys.up=true;
    if(e.code==='Enter'||e.code==='Space') Keys.start=true;
  });
  addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') Keys.left=false;
    if(e.code==='ArrowRight'||e.code==='KeyD') Keys.right=false;
    if(e.code==='ArrowUp'||e.code==='Space'||e.code==='KeyW') Keys.up=false;
    if(e.code==='Enter'||e.code==='Space') Keys.start=false;
  });

  // 画面
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');
  const W=canvas.width,H=canvas.height;

  const camera={x:0,y:0,lerp:0.15};
  function followCamera(target){
    const targetX=target.x - W*0.35; // 少し先を映す
    camera.x += (targetX - camera.x)*camera.lerp;
    camera.x = clamp(camera.x,0,LEVEL.width - W);
  }

  // レベル定義
  const LEVEL={
    width:5000,
    height:1000,
    spawn:{x:100,y:300},
    groundY:520,
    platforms:[
      {x:0,y:560,w:5000,h:200},
      {x:400,y:450,w:180,h:20},
      {x:700,y:420,w:200,h:20},
      {x:1050,y:370,w:160,h:20},
      {x:1350,y:450,w:140,h:20},
      {x:1600,y:400,w:200,h:20},
      {x:1900,y:350,w:200,h:20},
      {x:2200,y:300,w:180,h:20},
      {x:2500,y:350,w:200,h:20},
      {x:2800,y:420,w:180,h:20},
      {x:3200,y:380,w:220,h:20},
      {x:3500,y:340,w:220,h:20},
      {x:3850,y:300,w:220,h:20},
      {x:4200,y:360,w:200,h:20}
    ],
    enemies:[
      {x:820,y:390,w:34,h:34,vx:1.2,minX:700,maxX:900,dead:false,deadAt:0},
      {x:1970,y:316,w:34,h:34,vx:1.3,minX:1900,maxX:2100,dead:false,deadAt:0},
      {x:3220,y:346,w:34,h:34,vx:1.0,minX:3200,maxX:3400,dead:false,deadAt:0}
    ],
    goal:{ x:4700, y:520, w:40, h:120 } // ポール幅/高さを明示
  };

  // プレイヤー
  const player={
    x:LEVEL.spawn.x,
    y:LEVEL.spawn.y,
    w:34,h:42,
    vx:0,vy:0,
    speed:2.5,acc:0.7,maxSpeed:4.2,friction:0.78,jump:10.2,
    onGround:false,facing:1,stunnedUntil:0
  };

  // スプライト
  function loadImg(url){ if(!url) return null; const i=new Image(); i.src=url; return i; }
  const sprites={
    player:loadImg(PLAYER_SPRITE_URL),
    playerHit:loadImg(PLAYER_SPRITE_HIT_URL),
    enemy:loadImg(ENEMY_SPRITE_URL),
    enemyDead:loadImg(ENEMY_SPRITE_DEAD_URL)
  };

  // HUD
  let lives=3; const hudLivesText=document.getElementById('livesText');
  function updateHUD(){ hudLivesText.textContent='x'+lives; }
  updateHUD();

  // 衝突/物理
  const GRAVITY=0.5;
  function rectsOverlap(a,b){return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;}

  function moveAndCollide(ent){
    ent.x += ent.vx;
    for(const p of LEVEL.platforms){
      if(rectsOverlap(ent,p)){
        if(ent.vx>0) ent.x=p.x - ent.w; else if(ent.vx<0) ent.x=p.x + p.w;
        ent.vx=0;
      }
    }
    ent.vy += GRAVITY;
    ent.y += ent.vy;

    if(ent.y + ent.h >= LEVEL.groundY){
      ent.y = LEVEL.groundY - ent.h; ent.vy=0; ent.onGround=true;
    } else ent.onGround=false;

    for(const p of LEVEL.platforms){
      if(p.y < LEVEL.groundY-1 && rectsOverlap(ent,p)){
        if(ent.vy>0){ ent.y=p.y - ent.h; ent.vy=0; ent.onGround=true; }
        else if(ent.vy<0){ ent.y=p.y + p.h; ent.vy=0.5; }
      }
    }
  }

  function resetToSpawn(){
    player.x=LEVEL.spawn.x; player.y=LEVEL.spawn.y; player.vx=0; player.vy=0; player.onGround=false;
    camera.x = clamp(player.x - W*0.35, 0, LEVEL.width - W);
  }

  // ミス時の処理（バグ修正: リスポーンに戻す）
  function playerMiss(){
    if(now() < player.stunnedUntil) return; // 連続ヒット防止
    lives -= 1; updateHUD();
    player.stunnedUntil = now() + 2000; // 2秒スタン
    resetToSpawn(); // 即リスポーン
  }

  // 敵更新/処理
  function updateEnemies(){
    for(const e of LEVEL.enemies){
      if(e.dead) continue;
      e.x += e.vx;
      if(e.x < e.minX){ e.x=e.minX; e.vx*=-1; }
      if(e.x + e.w > e.maxX){ e.x=e.maxX - e.w; e.vx*=-1; }

      if(rectsOverlap(player,e)){
        // 踏みつけ判定
        const playerPrevBottom = (player.y + player.h) - player.vy; // おおよそ前フレーム底面
        const isStomp = playerPrevBottom <= e.y + 6 && player.vy > 0;
        if(isStomp){
          e.dead=true; e.deadAt=now();
          player.vy = -9.5; // バウンド
        } else {
          playerMiss();
        }
      }
    }
  }

  // 入力
  function controlPlayer(active){
    if(!active) return;
    const dir=(Keys.right?1:0) - (Keys.left?1:0);
    if(dir!==0){ player.vx += dir*player.acc; player.facing=dir; }
    else { player.vx *= player.friction; }
    player.vx = clamp(player.vx, -player.maxSpeed, player.maxSpeed);
    if(Keys.up && player.onGround){ player.vy = -player.jump; player.onGround=false; }
    if(player.y > H + 200){ playerMiss(); }
  }

  // 描画
  function drawBackground(){
    const skyGrad=ctx.createLinearGradient(0,0,0,H); skyGrad.addColorStop(0,'#171c3f'); skyGrad.addColorStop(1,'#0f1126');
    ctx.fillStyle=skyGrad; ctx.fillRect(0,0,W,H);
    ctx.save(); ctx.globalAlpha=.6; const ox=(camera.x*.2)%W; ctx.fillStyle='#fff';
    for(let i=0;i<80;i++){ const x=((i*61)%W)-ox; const y=(i*53)%(H*.6); ctx.fillRect(x,y+20,2,2);} ctx.restore();
    const hill=(baseY,amp,speed,color)=>{ ctx.save(); ctx.translate(-(camera.x*speed)%W,0); ctx.fillStyle=color; for(let k=-1;k<=2;k++){ ctx.beginPath(); ctx.moveTo(k*W,H); for(let x=0;x<=W;x+=20){ const y=baseY+Math.sin((x+k*W)*.003)*amp; ctx.lineTo(k*W+x,y);} ctx.lineTo((k+1)*W,H); ctx.closePath(); ctx.fill(); } ctx.restore(); };
    hill(480,30,.25,'#0b1331'); hill(520,40,.4,'#0a0f28');
  }

  function drawWorld(){
    // 地面ライン
    ctx.strokeStyle='#263158'; ctx.lineWidth=3; ctx.beginPath();
    ctx.moveTo(-camera.x, LEVEL.groundY + 1 - camera.y);
    ctx.lineTo(LEVEL.width - camera.x, LEVEL.groundY + 1 - camera.y); ctx.stroke();

    // プラットフォーム
    for(const p of LEVEL.platforms){ if(p===LEVEL.platforms[0]) continue; const x=p.x - camera.x, y=p.y - camera.y; ctx.fillStyle='#32406b'; ctx.fillRect(x,y,p.w,p.h); ctx.fillStyle='#415189'; ctx.fillRect(x,y,p.w,6); }

    // 敵
    const t=now();
    for(const e of LEVEL.enemies){
      const x=e.x - camera.x, y=e.y - camera.y;
      if(!e.dead){
        if(sprites.enemy) ctx.drawImage(sprites.enemy,x,y,e.w,e.h);
        else { ctx.fillStyle='#ff5964'; ctx.fillRect(x,y,e.w,e.h); ctx.fillStyle='#fff'; ctx.fillRect(x+8,y+10,6,6); ctx.fillRect(x+20,y+10,6,6); }
      } else {
        const deadElapsed=t - e.deadAt;
        if(sprites.enemyDead){ ctx.globalAlpha=Math.max(0,1-deadElapsed/500); ctx.drawImage(sprites.enemyDead,x,y,e.w,e.h); ctx.globalAlpha=1; }
        else { ctx.save(); ctx.translate(x + e.w/2, y + e.h/2); const s=18+Math.min(12,deadElapsed*.05); ctx.strokeStyle='#ff6b81'; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(-s,-s); ctx.lineTo(s,s); ctx.moveTo(s,-s); ctx.lineTo(-s,s); ctx.stroke(); ctx.restore(); }
        if(deadElapsed>600){ e.w=0; e.h=0; e.x=-99999; }
      }
    }

    // ゴール描画（バグ修正: 判定枠と一致させる）
    const g=LEVEL.goal; const gx=g.x - camera.x, gy=g.y - camera.y;
    // 柱
    ctx.fillStyle='#6b80d6'; ctx.fillRect(gx, gy - g.h, 8, g.h);
    // 旗
    ctx.beginPath(); ctx.moveTo(gx+8, gy - g.h + 5); ctx.lineTo(gx+8+40, gy - g.h + 20); ctx.lineTo(gx+8, gy - g.h + 35); ctx.closePath(); ctx.fillStyle='#ffd169'; ctx.fill();
  }

  function drawPlayer(){
    const px=player.x - camera.x, py=player.y - camera.y; const stunned = now() < player.stunnedUntil;
    if(stunned){
      if(sprites.playerHit){ ctx.save(); if(player.facing<0){ ctx.translate(px+player.w/2,0); ctx.scale(-1,1); ctx.translate(-px-player.w/2,0);} ctx.drawImage(sprites.playerHit,px,py,player.w,player.h); ctx.restore(); }
      else { ctx.fillStyle='#ff7777'; ctx.fillRect(px,py,player.w,player.h); ctx.fillStyle='#fff'; ctx.fillRect(px+8,py+10,6,6); }
    } else {
      if(sprites.player){ ctx.save(); if(player.facing<0){ ctx.translate(px+player.w/2,0); ctx.scale(-1,1); ctx.translate(-px-player.w/2,0);} ctx.drawImage(sprites.player,px,py,player.w,player.h); ctx.restore(); }
      else { ctx.fillStyle='#7aa2ff'; ctx.fillRect(px,py,player.w,player.h); ctx.fillStyle='#fff'; ctx.fillRect(px+8,py+10,6,6); }
    }
  }

  // クリア状態
  let state='playing';
  function drawClearBanner(){
    ctx.save(); ctx.globalAlpha=.95; ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(W/2-160, H/2-60, 320, 120);
    ctx.fillStyle='#fff'; ctx.font='bold 28px system-ui,sans-serif'; ctx.textAlign='center'; ctx.fillText('STAGE CLEAR!', W/2, H/2 - 10);
    ctx.font='14px system-ui,sans-serif'; ctx.fillText('Enter でリスタート', W/2, H/2 + 26); ctx.restore();
  }

  // ループ
  let last=0;
  function loop(t){
    requestAnimationFrame(loop);
    const dt=Math.min(32, t-last); last=t;

    drawBackground();

    if(state==='playing'){
      const active = now() >= player.stunnedUntil;
      controlPlayer(active);
      if(active) moveAndCollide(player);
      updateEnemies();
      followCamera(player);

      // バグ修正: ゴール判定
      const goalRect = { x: LEVEL.goal.x, y: LEVEL.goal.y - LEVEL.goal.h, w: LEVEL.goal.w, h: LEVEL.goal.h };
      if(rectsOverlap(player, goalRect)) state='clear';
    } else if(state==='clear'){
      // 余韻: 少しだけ慣性
      player.vx *= 0.95; player.vy += GRAVITY*0.5; moveAndCollide(player); followCamera(player);
      if(Keys.start){ // リスタート（ライフは引き継ぎ）
        resetToSpawn(); state='playing';
      }
    }

    drawWorld();
    drawPlayer();
    if(state==='clear') drawClearBanner();
  }
  requestAnimationFrame(loop);

  // 初期カメラ
  camera.x = clamp(player.x - W*0.35, 0, LEVEL.width - W);

  // デバッグAPI
  window.__game = { player, camera, LEVEL, miss: playerMiss };
  </script>
</body>
</html>